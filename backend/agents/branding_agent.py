import os
import random
import string
import json # Added for potential context data parsing
from typing import Dict, List, Any, Optional
from pydantic import BaseModel, Field

# Import ADK components
from google.adk.agents import LlmAgent
from google.adk.runtime import InvocationContext
from google.adk.runtime.events import Event

# Assuming ImprovedProductSpec structure is available or defined elsewhere
# Define input based on what BrandingAgent needs from ImprovedProductSpec
class BrandingAgentInput(BaseModel):
    """Input for the Branding Agent."""
    product_concept: str = Field(description="Description of the core product/model.")
    target_audience: List[str] = Field(description="Defined target demographics.")
    keywords: Optional[List[str]] = Field(None, description="Optional keywords related to the product/concept.")
    business_model_type: Optional[str] = Field(None, description="Optional: Type of business model (e.g., 'saas', 'e-commerce') to guide branding.")

# Define output based on the architecture plan and LLM generation
class ColorScheme(BaseModel):
    """Represents a suggested color scheme."""
    primary: str = Field(description="Primary color hex code (e.g., '#4A90E2')")
    secondary: str = Field(description="Secondary color hex code")
    accent: str = Field(description="Accent color hex code")
    background: str = Field(description="Background color hex code (often light/dark)")
    text: str = Field(description="Text color hex code (contrast with background)")
    rationale: str = Field(description="Explanation for the color choices")

class BrandPackage(BaseModel):
    """Output schema for the Branding Agent, generated by an LLM."""
    brand_name_suggestions: List[str] = Field(description="List of suggested brand names.")
    tagline_suggestions: List[str] = Field(description="List of suggested taglines/slogans.")
    selected_brand_name: str = Field(description="The primary recommended brand name.")
    selected_tagline: str = Field(description="The primary recommended tagline.")
    color_scheme: ColorScheme = Field(description="Suggested color scheme with rationale.")
    logo_concepts: List[str] = Field(description="Textual descriptions of potential logo concepts/styles.")
    visual_identity_rationale: str = Field(description="Overall rationale for the visual identity direction (colors, logo ideas).")
    positioning_statement: str = Field(description="Statement defining the brand's market position.")
    key_messages: List[str] = Field(description="Core messages the brand should communicate.")
    voice_tone: List[str] = Field(description="Keywords describing the desired brand voice and tone.")
    target_demographics: List[str] = Field(description="Target demographics provided as input.") # Keep from input for context

# --- Agent Class ---

class BrandingAgent(LlmAgent): # Inherit from LlmAgent
    """
    ADK Agent responsible for Stage 3: Rebranding.
    Generates a brand identity based on the improved product specification.
    """
    def __init__(self, agent_id: str = "branding_agent"): # Add agent_id and call parent init
        """Initialize the Branding Agent."""
        super().__init__(agent_id=agent_id)
        """Initialize the Branding Agent."""
        # No need to load elements, LLM will generate them.
        pass # Placeholder if no other init logic needed

    async def run_async(self, context: InvocationContext) -> Event:
        """Executes the branding generation workflow using an LLM."""
        self.logger.info(f"Starting LLM-based branding generation for context: {context.invocation_id}")

        try:
            # 1. Parse Input from context
            if not isinstance(context.input.data, dict):
                try:
                    input_data = json.loads(context.input.data)
                except json.JSONDecodeError as e:
                    self.logger.error(f"Input data is not a valid dictionary or JSON string: {context.input.data}")
                    raise ValueError(f"Input data is not a valid dictionary or JSON string: {e}") from e
            else:
                input_data = context.input.data

            # Validate input using Pydantic model
            try:
                inputs = BrandingAgentInput(**input_data)
                self.logger.info(f"Parsed input: Concept='{inputs.product_concept}', Audience='{inputs.target_audience}', Keywords='{inputs.keywords}', Model='{inputs.business_model_type}'")
            except Exception as e: # Catch Pydantic validation errors
                 self.logger.error(f"Input validation failed: {e}. Input data: {input_data}")
                 raise ValueError(f"Input validation failed: {e}") from e

            # 2. Construct LLM Prompt
            prompt = f"""
            You are a creative branding expert. Based on the following product specification, generate a comprehensive branding package.

            Product Concept: {inputs.product_concept}
            Target Audience: {', '.join(inputs.target_audience)}
            Keywords: {', '.join(inputs.keywords) if inputs.keywords else 'None provided'}
            Business Model Type: {inputs.business_model_type or 'Not specified'}

            Generate the following branding elements:
            1.  **Brand Name Suggestions:** Provide 3-5 creative and relevant brand name suggestions.
            2.  **Tagline Suggestions:** Provide 3-5 catchy taglines or slogans that align with the brand.
            3.  **Selected Brand Name:** Choose the strongest brand name from your suggestions.
            4.  **Selected Tagline:** Choose the strongest tagline from your suggestions.
            5.  **Color Scheme:** Suggest a color scheme with primary, secondary, accent, background, and text hex codes. Provide a brief rationale for the choices, considering the target audience and product concept.
            6.  **Logo Concepts:** Describe 2-3 distinct concepts or styles for a logo (e.g., "minimalist wordmark using a sans-serif font", "abstract icon representing data flow").
            7.  **Visual Identity Rationale:** Briefly explain the overall visual direction suggested by the colors and logo concepts.
            8.  **Positioning Statement:** Write a concise statement defining the brand's unique position in the market for its target audience.
            9.  **Key Messages:** List 3-4 core messages the brand should communicate.
            10. **Voice & Tone:** List 3-5 keywords describing the desired brand voice (e.g., "innovative", "approachable", "authoritative").

            Please format your response as a JSON object matching the following Pydantic model structure:

            ```json
            {{
                "brand_name_suggestions": ["Name1", "Name2", "Name3"],
                "tagline_suggestions": ["Tagline1", "Tagline2", "Tagline3"],
                "selected_brand_name": "Name1",
                "selected_tagline": "Tagline2",
                "color_scheme": {{
                    "primary": "#XXXXXX",
                    "secondary": "#XXXXXX",
                    "accent": "#XXXXXX",
                    "background": "#XXXXXX",
                    "text": "#XXXXXX",
                    "rationale": "Rationale text..."
                }},
                "logo_concepts": ["Concept description 1", "Concept description 2"],
                "visual_identity_rationale": "Overall rationale text...",
                "positioning_statement": "Positioning statement text...",
                "key_messages": ["Message 1", "Message 2", "Message 3"],
                "voice_tone": ["Tone1", "Tone2", "Tone3"]
            }}
            ```
            Ensure the output is a single, valid JSON object only.
            """

            # 3. Call LLM
            self.logger.info("Sending request to LLM for branding generation.")
            llm_response_text = await self.llm_client.generate_text_async(prompt=prompt)
            self.logger.debug(f"Raw LLM response: {llm_response_text}") # Log raw response for debugging

            # 4. Parse LLM Response
            try:
                # Clean potential markdown code fences
                if llm_response_text.strip().startswith("```json"):
                    llm_response_text = llm_response_text.strip()[7:-3].strip()
                elif llm_response_text.strip().startswith("```"):
                     llm_response_text = llm_response_text.strip()[3:-3].strip()

                llm_data = json.loads(llm_response_text)
                self.logger.info("Successfully parsed LLM response JSON.")
            except json.JSONDecodeError as e:
                self.logger.error(f"Failed to parse LLM response as JSON: {e}. Response: {llm_response_text}")
                raise ValueError(f"LLM response was not valid JSON: {e}") from e
            except Exception as e: # Catch other potential errors during parsing
                self.logger.error(f"An unexpected error occurred during LLM response parsing: {e}. Response: {llm_response_text}")
                raise ValueError(f"Could not process LLM response: {e}") from e


            # 5. Validate and Assemble Brand Package
            try:
                # Add target demographics back into the package
                llm_data['target_demographics'] = inputs.target_audience
                brand_package = BrandPackage(**llm_data)
                self.logger.info("Successfully validated LLM data against BrandPackage model.")
            except Exception as e: # Catch Pydantic validation errors
                self.logger.error(f"LLM response data failed validation: {e}. Data: {llm_data}")
                raise ValueError(f"LLM response data failed validation: {e}") from e

            # 6. Return Success Event
            self.logger.info("Branding generation finished successfully using LLM.")
            return Event(
                event_type="adk.agent.result",
                data=brand_package.model_dump(), # Serialize the Pydantic model
                metadata={"status": "success"}
            )

        except ValueError as ve: # Catch specific validation/parsing errors
             self.logger.error(f"BrandingAgent execution failed due to ValueError: {ve}", exc_info=True)
             return Event(
                 event_type="adk.agent.error",
                 data={"error": "Input or LLM Response Error", "details": str(ve)},
                 metadata={"status": "error"}
             )
        except Exception as e: # Catch broader errors (e.g., LLM client issues)
            self.logger.error(f"BrandingAgent execution failed unexpectedly: {e}", exc_info=True)
            return Event(
                event_type="adk.agent.error",
                data={"error": "Internal Agent Error", "details": f"An unexpected error occurred: {str(e)}"},
                metadata={"status": "error"}
            )

# Removed the old _load_branding_elements, _generate_brand_name, _generate_color_scheme, _generate_positioning methods
# Removed the if __name__ == "__main__": block