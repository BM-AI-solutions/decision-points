"""
Branding Agent for Decision Points (ADK Version).

This agent generates a brand identity based on product specifications using ADK tools.
"""

import asyncio
import json
import logging
from typing import Dict, List, Any, Optional, Tuple

import google.generativeai as genai
from pydantic import BaseModel, Field

# ADK Imports
from google.adk.agents import Agent # Use ADK Agent
from google.adk.tools import tool, ToolContext # Import tool decorator and context
from google.adk.events import Event # Import Event for tool return type

# Removed A2A Imports

# Removed BaseSpecializedAgent import
from app.config import settings

# Configure logging
logger = logging.getLogger(__name__)

# --- LLM Initialization ---
try:
    genai.configure(api_key=settings.GEMINI_API_KEY)
    gemini_model_name = settings.GEMINI_MODEL_NAME # Or a specific one like 'gemini-1.5-flash'
    gemini_model = genai.GenerativeModel(
        gemini_model_name,
        generation_config=genai.types.GenerationConfig(temperature=0.7)
    )
    logger.info(f"Direct Gemini model {gemini_model_name} initialized for branding tools.")
except Exception as e:
    logger.error(f"Failed to initialize direct Gemini model: {e}")
    gemini_model = None

# --- Pydantic Models (Keep as they define data structures) ---

class BrandingAgentInput(BaseModel):
    """Input for the Branding Agent."""
    product_concept: str = Field(description="Description of the core product/model.")
    target_audience: List[str] = Field(description="Defined target demographics.")
    keywords: Optional[List[str]] = Field(None, description="Optional keywords related to the product/concept.")
    business_model_type: Optional[str] = Field(None, description="Optional: Type of business model (e.g., 'saas', 'e-commerce') to guide branding.")

class ColorScheme(BaseModel):
    """Represents a suggested color scheme."""
    primary: str = Field(description="Primary color hex code (e.g., '#4A90E2')")
    secondary: str = Field(description="Secondary color hex code")
    accent: str = Field(description="Accent color hex code")
    background: str = Field(description="Background color hex code (often light/dark)")
    text: str = Field(description="Text color hex code (contrast with background)")
    rationale: str = Field(description="Explanation for the color choices")

class Suggestion(BaseModel):
    """Represents a suggestion with its rationale."""
    value: str = Field(description="The suggested item (e.g., brand name, tagline).")
    rationale: str = Field(description="The reasoning behind the suggestion.")

class SelectedItem(BaseModel):
    """Represents a selected item with its justification."""
    value: str = Field(description="The selected item.")
    justification: str = Field(description="The reason for selecting this item.")

class LogoConcept(BaseModel):
    """Represents a logo concept description with its intended message."""
    description: str = Field(description="Detailed description of the logo concept/style.")
    message: str = Field(description="The feeling or message the concept aims to convey.")

class VoiceTone(BaseModel):
    """Represents the brand's voice and tone."""
    keywords: List[str] = Field(description="Keywords describing the desired brand voice.")
    description: str = Field(description="Brief description elaborating on the voice/tone.")

class BrandPackage(BaseModel):
    """Output schema for the Branding Agent, generated by an LLM."""
    brand_name_suggestions: List[Suggestion] = Field(description="List of suggested brand names with rationales.")
    tagline_suggestions: List[Suggestion] = Field(description="List of suggested taglines/slogans with rationales.")
    selected_brand_name: SelectedItem = Field(description="The primary recommended brand name with justification.")
    selected_tagline: SelectedItem = Field(description="The primary recommended tagline with justification.")
    color_scheme: ColorScheme = Field(description="Suggested color scheme with rationale.")
    logo_concepts: List[LogoConcept] = Field(description="Descriptions of potential logo concepts/styles with intended messages.")
    visual_identity_rationale: str = Field(description="Overall rationale for the visual identity direction (colors, logo ideas).")
    positioning_statement: str = Field(description="Statement defining the brand's market position.")
    key_messages: List[str] = Field(description="Core messages the brand should communicate.")
    voice_tone: VoiceTone = Field(description="Description of the desired brand voice and tone.")
    target_demographics: List[str] = Field(description="Target demographics provided as input.", default=[])
    availability_notes: Optional[Dict[str, str]] = Field(None, description="Summary of availability checks for suggested names (domain, social, trademark).")

# --- Helper Function for Availability Check (Refactored for ADK) ---

async def _check_name_availability(context: ToolContext, name: str) -> Tuple[str, str]:
    """
    Checks domain, social, and potentially trademark availability using the WebSearch ADK agent.
    Returns a tuple: (summary_string, availability_status).
    Status can be 'available', 'likely_taken', 'uncertain', 'error', or 'skipped'.
    """
    target_adk_agent_id = "web_search_adk" # Name of the refactored web search agent

    # Simple check for common TLDs
    domain_query = f"Is the domain name {name.replace(' ', '').lower()}.com available?"
    social_query = f"Are social media handles for '{name}' available on major platforms (Twitter, Instagram, Facebook)?"
    trademark_query = f"Are there existing trademarks or widely known brands called '{name}'?"

    queries = {
        "domain": domain_query,
        "social": social_query,
        "trademark": trademark_query
    }
    results = {}
    raw_search_details = {}

    async def perform_adk_search(query_type: str, query: str):
        try:
            logger.info(f"Invoking ADK agent '{target_adk_agent_id}' for '{name}' ({query_type})...")
            input_event = Event(data={"query": query})
            response_event = await context.invoke_agent(
                target_agent_id=target_adk_agent_id,
                input=input_event,
                timeout_seconds=30.0
            )

            # Extract results from the response event
            search_result_data = {}
            if response_event and response_event.actions and response_event.actions[0].content and response_event.actions[0].content.parts:
                 # Assuming the result is in the first text part's data
                 part_data = response_event.actions[0].content.parts[0].data
                 if isinstance(part_data, dict):
                     search_result_data = part_data
                 else: # Fallback if data is just text
                     search_result_data = {"text": str(part_data)}

            elif response_event and response_event.actions and response_event.actions[0].parts:
                 # Fallback for tool output directly in parts
                 part_data = response_event.actions[0].parts[0].data
                 if isinstance(part_data, dict):
                     search_result_data = part_data
                 else:
                     search_result_data = {"text": str(part_data)}


            if search_result_data and "results" in search_result_data:
                search_results_list = search_result_data["results"]
                raw_search_details[query_type] = f"{str(search_results_list)[:150]}..."
                # Basic interpretation
                if "available" in str(search_results_list).lower() and "not available" not in str(search_results_list).lower():
                    results[query_type] = "Likely Available"
                elif "not available" in str(search_results_list).lower() or "taken" in str(search_results_list).lower():
                    results[query_type] = "Likely Unavailable"
                else:
                    results[query_type] = "Unclear/Check Manually"
            elif search_result_data and "error" in search_result_data:
                 error_msg = search_result_data.get("error", "Unknown error from WebSearchAgent")
                 logger.warning(f"WebSearchAgent invocation for '{name}' ({query_type}) returned error: {error_msg}")
                 results[query_type] = "Error during check"
                 raw_search_details[query_type] = f"Agent Error: {error_msg}"
            else:
                logger.warning(f"WebSearchAgent invocation for '{name}' ({query_type}) returned unexpected payload: {response_event}")
                results[query_type] = "Unknown response format"
                raw_search_details[query_type] = "Unknown response format."

        except Exception as e:
            logger.error(f"Error invoking ADK agent '{target_adk_agent_id}' for '{name}' ({query_type}): {e}", exc_info=True)
            results[query_type] = "Error during check"
            raw_search_details[query_type] = f"Invocation Error: {str(e)}"

    # Run searches concurrently
    tasks = [perform_adk_search(q_type, q_text) for q_type, q_text in queries.items()]
    await asyncio.gather(*tasks)

    # Format summary string
    summary_str = (
        f"Domain: {results.get('domain', 'N/A')} ({raw_search_details.get('domain', 'N/A')}). "
        f"Social: {results.get('social', 'N/A')} ({raw_search_details.get('social', 'N/A')}). "
        f"Trademark: {results.get('trademark', 'N/A')} ({raw_search_details.get('trademark', 'N/A')})"
    )
    logger.info(f"Availability check summary for '{name}': {summary_str}")

    # Determine overall status
    domain_status = results.get('domain')
    social_status = results.get('social')
    trademark_status = results.get('trademark')

    if any(s and 'Error' in s for s in results.values()): status = 'error'
    elif domain_status == "Likely Unavailable" or trademark_status == "Likely Unavailable": status = 'likely_taken'
    elif domain_status == "Likely Available" and social_status != "Likely Unavailable": status = 'available'
    else: status = 'uncertain'

    logger.info(f"Determined availability status for '{name}': {status}")
    return summary_str, status

# --- ADK Tool Definitions ---

@tool(description="Generate a comprehensive brand identity package based on product concept, audience, and keywords.")
async def generate_brand_tool(
    context: ToolContext, # Add context for invoking other agents
    product_concept: str,
    target_audience: List[str],
    keywords: Optional[List[str]] = None,
    business_model_type: Optional[str] = None
) -> Dict[str, Any]:
    """
    ADK Tool: Generate a comprehensive brand identity package.
    """
    logger.info(f"Tool: Generating brand identity for product concept: {product_concept}")

    if not gemini_model:
        return {"success": False, "error": "Gemini model not initialized"}

    try:
        # Create input model
        inputs = BrandingAgentInput(
            product_concept=product_concept,
            target_audience=target_audience,
            keywords=keywords,
            business_model_type=business_model_type
        )

        # Construct LLM Prompt (same as before)
        prompt = f"""
        You are a highly creative and strategic branding expert tasked with developing a compelling brand identity.
        Deeply analyze the provided product specification:

        **Core Product Concept:**
        {inputs.product_concept}

        **Target Audience:**
        {', '.join(inputs.target_audience)}

        **Keywords (if any):**
        {', '.join(inputs.keywords) if inputs.keywords else 'None provided'}

        **Business Model Type (if specified):**
        {inputs.business_model_type or 'Not specified'}

        ---

        **Your Task:** Generate a comprehensive and creative branding package. Ensure all elements are consistent and reinforce a unified brand identity.

        **Required Branding Elements:**

        1.  **Brand Name Suggestions (3-5):** Rationale required.
        2.  **Tagline Suggestions (3-5):** Rationale required.
        3.  **Selected Brand Name:** Justification required.
        4.  **Selected Tagline:** Justification required.
        5.  **Color Scheme:** Hex codes and detailed rationale required.
        6.  **Logo Concepts (2-3):** Detailed descriptions and intended message required.
        7.  **Visual Identity Rationale:** Summary explaining synergy required.
        8.  **Positioning Statement:** Clear statement required.
        9.  **Key Messages (3-4):** Benefit-oriented messages required.
        10. **Voice & Tone:** Keywords and description required.

        ---

        **Output Format:**
        Strictly format your entire response as a single, valid JSON object. Adhere precisely to the following Pydantic model structure (do not include markdown code fences ```json or ```):

        ```json
        {{
            "brand_name_suggestions": [ {{"value": "Name1", "rationale": "..."}}, ... ],
            "tagline_suggestions": [ {{"value": "Tagline1", "rationale": "..."}}, ... ],
            "selected_brand_name": {{"value": "Selected Name", "justification": "..."}},
            "selected_tagline": {{"value": "Selected Tagline", "justification": "..."}},
            "color_scheme": {{ "primary": "#...", "secondary": "#...", "accent": "#...", "background": "#...", "text": "#...", "rationale": "..." }},
            "logo_concepts": [ {{"description": "...", "message": "..."}}, ... ],
            "visual_identity_rationale": "...",
            "positioning_statement": "...",
            "key_messages": [ "...", "...", ... ],
            "voice_tone": {{ "keywords": ["...", ...], "description": "..." }}
        }}
        ```
        Ensure all fields are populated according to the instructions above. The output MUST be only the JSON object.
        """

        # Call LLM
        logger.info("Tool: Sending request to LLM for branding generation.")
        response = await gemini_model.generate_content_async(prompt)
        llm_response_text = response.text

        # Parse LLM Response
        try:
            if llm_response_text.strip().startswith("```json"):
                llm_response_text = llm_response_text.strip()[7:-3].strip()
            elif llm_response_text.strip().startswith("```"):
                 llm_response_text = llm_response_text.strip()[3:-3].strip()
            llm_data = json.loads(llm_response_text)
            logger.info("Tool: Successfully parsed LLM response JSON.")
        except json.JSONDecodeError as e:
            logger.error(f"Tool: Failed to parse LLM response as JSON: {e}")
            return {"success": False, "error": f"Failed to parse LLM response: {str(e)}"}

        # Perform Availability Checks using the helper
        availability_notes: Dict[str, str] = {}
        availability_statuses: Dict[str, str] = {}
        brand_suggestions = llm_data.get("brand_name_suggestions", [])
        suggested_names = [s.get("value") for s in brand_suggestions if s.get("value")]

        if suggested_names:
            logger.info(f"Tool: Checking availability for suggested names: {suggested_names}")
            for name in suggested_names:
                # Pass the ToolContext to the helper
                summary, status = await _check_name_availability(context, name)
                availability_notes[name] = summary
                availability_statuses[name] = status
            logger.info(f"Tool: Availability check statuses: {availability_statuses}")

        # Analyze Availability and Select Final Name (same logic as before)
        original_selected_name_item = llm_data.get("selected_brand_name", {})
        original_selected_name = original_selected_name_item.get("value")
        final_selected_name_item = original_selected_name_item

        if original_selected_name and original_selected_name in availability_statuses:
            original_status = availability_statuses[original_selected_name]
            if original_status != 'available':
                found_available_alternative = False
                for suggestion_item in brand_suggestions:
                    suggestion_name = suggestion_item.get("value")
                    if suggestion_name and availability_statuses.get(suggestion_name) == 'available':
                        original_rationale = suggestion_item.get("rationale", "N/A")
                        final_selected_name_item = {
                            "value": suggestion_name,
                            "justification": f"Selected based on availability ('available'). Original rationale: {original_rationale}"
                        }
                        found_available_alternative = True
                        break
                if not found_available_alternative:
                     final_selected_name_item["justification"] = f"{original_selected_name_item.get('justification', '')} (Availability Status: {original_status})"

        llm_data["selected_brand_name"] = final_selected_name_item

        # Validate and Assemble Final Brand Package
        try:
            if 'target_demographics' not in llm_data:
                llm_data['target_demographics'] = inputs.target_audience
            brand_package = BrandPackage(**llm_data)
            brand_package.availability_notes = availability_notes
            logger.info("Tool: Successfully validated LLM data and added availability notes.")
            return {
                "success": True,
                "message": "Brand identity generated successfully.",
                **brand_package.model_dump()
            }
        except Exception as e:
            logger.error(f"Tool: LLM response data failed validation: {e}")
            return {"success": False, "error": f"Validation failed: {str(e)}", "partial_data": llm_data}

    except Exception as e:
        logger.error(f"Tool: Error generating brand identity: {e}", exc_info=True)
        return {"success": False, "error": f"Error generating brand identity: {str(e)}"}

@tool(description="Check domain, social, and trademark availability for a brand name using the Web Search agent.")
async def check_name_availability_tool(context: ToolContext, name: str) -> Dict[str, Any]:
    """
    ADK Tool: Check domain, social, and trademark availability for a brand name.
    """
    logger.info(f"Tool: Checking availability for brand name: {name}")
    try:
        # Pass context to the helper
        summary, status = await _check_name_availability(context, name)
        return {"success": True, "name": name, "status": status, "summary": summary}
    except Exception as e:
        logger.error(f"Tool: Error checking name availability: {e}", exc_info=True)
        return {"success": False, "name": name, "error": f"Error checking availability: {str(e)}"}


# --- Instantiate the ADK Agent ---
agent = Agent(
    name="branding_adk", # ADK specific name
    description="Generates brand identity packages and checks name availability.",
    tools=[
        generate_brand_tool,
        check_name_availability_tool,
    ],
)

# Removed A2A server specific code and old class structure
