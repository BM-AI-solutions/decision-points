"""
Branding Agent for Decision Points.

This agent generates a brand identity based on the improved product specification.
It implements the A2A protocol for agent communication.
"""

import random
import string
import httpx
import asyncio
import json
import logging
from typing import Dict, List, Any, Optional
from pydantic import BaseModel, Field

# ADK Imports
from google.adk.runtime import InvocationContext
from google.adk.runtime.events import Event

# A2A Imports
from python_a2a import skill

from agents.base_agent import BaseSpecializedAgent
from app.config import settings

# Configure logging
logger = logging.getLogger(__name__)

# Assuming ImprovedProductSpec structure is available or defined elsewhere
# Define input based on what BrandingAgent needs from ImprovedProductSpec
class BrandingAgentInput(BaseModel):
    """Input for the Branding Agent."""
    product_concept: str = Field(description="Description of the core product/model.")
    target_audience: List[str] = Field(description="Defined target demographics.")
    keywords: Optional[List[str]] = Field(None, description="Optional keywords related to the product/concept.")
    business_model_type: Optional[str] = Field(None, description="Optional: Type of business model (e.g., 'saas', 'e-commerce') to guide branding.")

# Define output based on the architecture plan and LLM generation
class ColorScheme(BaseModel):
    """Represents a suggested color scheme."""
    primary: str = Field(description="Primary color hex code (e.g., '#4A90E2')")
    secondary: str = Field(description="Secondary color hex code")
    accent: str = Field(description="Accent color hex code")
    background: str = Field(description="Background color hex code (often light/dark)")
    text: str = Field(description="Text color hex code (contrast with background)")
    rationale: str = Field(description="Explanation for the color choices")

# Define structured suggestions
class Suggestion(BaseModel):
    """Represents a suggestion with its rationale."""
    value: str = Field(description="The suggested item (e.g., brand name, tagline).")
    rationale: str = Field(description="The reasoning behind the suggestion.")

class SelectedItem(BaseModel):
    """Represents a selected item with its justification."""
    value: str = Field(description="The selected item.")
    justification: str = Field(description="The reason for selecting this item.")

class LogoConcept(BaseModel):
    """Represents a logo concept description with its intended message."""
    description: str = Field(description="Detailed description of the logo concept/style.")
    message: str = Field(description="The feeling or message the concept aims to convey.")

class VoiceTone(BaseModel):
    """Represents the brand's voice and tone."""
    keywords: List[str] = Field(description="Keywords describing the desired brand voice.")
    description: str = Field(description="Brief description elaborating on the voice/tone.")


class BrandPackage(BaseModel):
    """Output schema for the Branding Agent, generated by an LLM."""
    brand_name_suggestions: List[Suggestion] = Field(description="List of suggested brand names with rationales.")
    tagline_suggestions: List[Suggestion] = Field(description="List of suggested taglines/slogans with rationales.")
    selected_brand_name: SelectedItem = Field(description="The primary recommended brand name with justification.")
    selected_tagline: SelectedItem = Field(description="The primary recommended tagline with justification.")
    color_scheme: ColorScheme = Field(description="Suggested color scheme with rationale.")
    logo_concepts: List[LogoConcept] = Field(description="Descriptions of potential logo concepts/styles with intended messages.")
    visual_identity_rationale: str = Field(description="Overall rationale for the visual identity direction (colors, logo ideas).")
    positioning_statement: str = Field(description="Statement defining the brand's market position.")
    key_messages: List[str] = Field(description="Core messages the brand should communicate.")
    voice_tone: VoiceTone = Field(description="Description of the desired brand voice and tone.")
    target_demographics: List[str] = Field(description="Target demographics provided as input.", default=[]) # Keep from input, add default
    availability_notes: Optional[Dict[str, str]] = Field(None, description="Summary of availability checks for suggested names (domain, social, trademark).")

# --- Agent Class ---

class BrandingAgent(BaseSpecializedAgent):
    """
    Agent responsible for branding.
    Generates a brand identity based on the improved product specification.
    Implements A2A protocol for agent communication.
    """
    def __init__(
        self,
        name: str = "branding",
        description: str = "Generates a brand identity based on the improved product specification",
        model_name: Optional[str] = None,
        port: Optional[int] = None,
        agent_web_search_id: Optional[str] = None,
        **kwargs: Any,
    ):
        """
        Initialize the BrandingAgent.

        Args:
            name: The name of the agent.
            description: The description of the agent.
            model_name: The name of the model to use. Defaults to settings.GEMINI_MODEL_NAME.
            port: The port to run the A2A server on. Defaults to settings.BRANDING_AGENT_URL port.
            agent_web_search_id: The ID of the WebSearchAgent.
            **kwargs: Additional arguments for BaseSpecializedAgent.
        """
        # Extract port from URL if not provided
        if port is None and settings.BRANDING_AGENT_URL:
            try:
                port = int(settings.BRANDING_AGENT_URL.split(':')[-1])
            except (ValueError, IndexError):
                port = 8006  # Default port

        # Initialize BaseSpecializedAgent
        super().__init__(
            name=name,
            description=description,
            model_name=model_name,
            port=port,
            **kwargs
        )

        # Prioritize passed ID, fallback to central settings
        self.agent_web_search_id = agent_web_search_id if agent_web_search_id is not None else settings.AGENT_WEB_SEARCH_ID

        if not self.agent_web_search_id:
            logger.warning("AGENT_WEB_SEARCH_ID is not configured (checked constructor arg and settings). Availability checks will be skipped.")
        else:
            logger.info(f"Using WebSearchAgent ID: {self.agent_web_search_id}")

        logger.info(f"BrandingAgent initialized with port: {self.port}")

    async def _check_name_availability(self, name: str) -> tuple[str, str]:
        """
        Checks domain, social, and potentially trademark availability for a given name.
        Returns a tuple: (summary_string, availability_status).
        Status can be 'available', 'likely_taken', 'uncertain', 'error', or 'skipped'.
        """
        if not self.agent_web_search_id:
            logger.warning(f"Skipping availability check for '{name}' due to missing configuration.")
            return "Availability check skipped (missing configuration).", "skipped"

        # Simple check for common TLDs - more sophisticated checks might be needed
        domain_query = f"Is the domain name {name.replace(' ', '').lower()}.com available?"
        social_query = f"Are social media handles for '{name}' available on major platforms (Twitter, Instagram, Facebook)?"
        # Trademark check is complex, a simple search might just look for existing usage
        trademark_query = f"Are there existing trademarks or widely known brands called '{name}'?"

        queries = {
            "domain": domain_query,
            "social": social_query,
            "trademark": trademark_query
        }
        results = {}
        raw_search_details = {} # Store snippets for summary

        async def perform_search(query_type: str, query: str):
            try:
                from agents.agent_network import agent_network

                # Get the agent from the network
                agent = agent_network.get_agent("web_search")
                if not agent:
                    logger.error("WebSearchAgent not found in agent network.")
                    results[query_type] = "Error during check"
                    raw_search_details[query_type] = "WebSearchAgent not found in agent network."
                    return

                logger.info(f"Invoking WebSearchAgent skill 'web_search' for '{name}' ({query_type}) via agent network...")

                # Invoke the web_search skill
                search_result = await agent.invoke_skill(
                    skill_name="web_search",
                    input_data={"query": query},
                    timeout=30.0
                )

                if search_result and "results" in search_result:
                    search_result_data = search_result["results"]
                    # Basic interpretation (can be improved)
                    raw_search_details[query_type] = f"{str(search_result_data)[:150]}..." # Store for summary
                    if "available" in str(search_result_data).lower() and "not available" not in str(search_result_data).lower():
                        results[query_type] = "Likely Available"
                    elif "not available" in str(search_result_data).lower() or "taken" in str(search_result_data).lower():
                        results[query_type] = "Likely Unavailable"
                    else:
                        results[query_type] = "Unclear/Check Manually"
                else:
                    # Handle cases where the skill call succeeded but indicated an internal failure or unexpected payload
                    error_msg = search_result.get("error", "Unknown or unsuccessful response from WebSearchAgent skill")
                    logger.warning(f"WebSearchAgent skill call for '{name}' ({query_type}) reported failure or unexpected payload: {error_msg}")
                    results[query_type] = "Unknown response format"
                    raw_search_details[query_type] = "Unknown response format."
            except Exception as e:
                logger.error(f"Error calling WebSearchAgent for '{name}' ({query_type}): {e}", exc_info=True)
                results[query_type] = "Error during check"
                raw_search_details[query_type] = f"Error: {str(e)}"

        # Run searches concurrently
        tasks = [perform_search(q_type, q_text) for q_type, q_text in queries.items()]
        await asyncio.gather(*tasks)

        # Format summary string including raw details
        summary_str = (
            f"Domain: {results.get('domain', 'N/A')} ({raw_search_details.get('domain', 'N/A')}). "
            f"Social: {results.get('social', 'N/A')} ({raw_search_details.get('social', 'N/A')}). "
            f"Trademark: {results.get('trademark', 'N/A')} ({raw_search_details.get('trademark', 'N/A')})"
        )
        logger.info(f"Availability check summary for '{name}': {summary_str}")

        # Determine overall status
        domain_status = results.get('domain')
        social_status = results.get('social')
        trademark_status = results.get('trademark')

        if any(s and 'Error' in s for s in results.values()):
            status = 'error'
        elif domain_status == "Likely Unavailable" or trademark_status == "Likely Unavailable":
            status = 'likely_taken'
        elif domain_status == "Likely Available" and social_status != "Likely Unavailable":
            # Prioritize domain availability, allow social to be unclear/taken if domain is good
            status = 'available'
        else: # Covers cases where domain is unclear, or domain is available but social is unavailable etc.
            status = 'uncertain'

        logger.info(f"Determined availability status for '{name}': {status}")
        return summary_str, status


    # --- A2A Skills ---
    @skill(
        name="generate_brand",
        description="Generate a comprehensive brand identity package",
        tags=["branding", "identity"]
    )
    async def generate_brand(self, product_concept: str, target_audience: List[str],
                            keywords: Optional[List[str]] = None,
                            business_model_type: Optional[str] = None) -> Dict[str, Any]:
        """
        Generate a comprehensive brand identity package.

        Args:
            product_concept: Description of the core product/model.
            target_audience: Defined target demographics.
            keywords: Optional keywords related to the product/concept.
            business_model_type: Optional type of business model (e.g., 'saas', 'e-commerce').

        Returns:
            A dictionary containing the brand identity package.
        """
        logger.info(f"Generating brand identity for product concept: {product_concept}")

        try:
            # Create input model
            inputs = BrandingAgentInput(
                product_concept=product_concept,
                target_audience=target_audience,
                keywords=keywords,
                business_model_type=business_model_type
            )

            # Construct LLM Prompt
            prompt = f"""
            You are a highly creative and strategic branding expert tasked with developing a compelling brand identity.
            Deeply analyze the provided product specification:

            **Core Product Concept:**
            {inputs.product_concept}

            **Target Audience:**
            {', '.join(inputs.target_audience)}

            **Keywords (if any):**
            {', '.join(inputs.keywords) if inputs.keywords else 'None provided'}

            **Business Model Type (if specified):**
            {inputs.business_model_type or 'Not specified'}

            ---

            **Your Task:** Generate a comprehensive and creative branding package. Ensure all elements are consistent and reinforce a unified brand identity.

            **Required Branding Elements:**

            1.  **Brand Name Suggestions (3-5):**
                *   Generate a diverse list of creative, memorable, and relevant brand names.
                *   Consider different styles (e.g., descriptive, evocative, abstract, invented).
                *   Briefly explain the rationale and relevance of *each* suggestion in relation to the product concept and target audience.

            2.  **Tagline Suggestions (3-5):**
                *   Generate catchy, impactful taglines/slogans.
                *   Each tagline should strongly align with the product's core value proposition and resonate with the target audience.
                *   Briefly explain the rationale for *each* tagline.

            3.  **Selected Brand Name:**
                *   Choose the *single strongest* brand name from your suggestions. Justify your choice.

            4.  **Selected Tagline:**
                *   Choose the *single strongest* tagline from your suggestions. Justify your choice.

            5.  **Color Scheme:**
                *   Suggest a cohesive color scheme including primary, secondary, accent, background (light/dark), and text hex codes.
                *   Provide a detailed rationale explaining the psychological impact of the color choices and how they align with the brand's desired image, product concept, and target audience.

            6.  **Logo Concepts (2-3):**
                *   Describe distinct and evocative concepts or styles for a logo (e.g., "Geometric wordmark using a modern, bold sans-serif font, conveying stability and innovation", "Abstract icon symbolizing [key concept] with fluid lines, suggesting adaptability").
                *   Go beyond simple descriptions; explain the *feeling* or *message* each concept aims to convey.

            7.  **Visual Identity Rationale:**
                *   Provide a concise summary explaining how the suggested color scheme and logo concepts work together to create a cohesive and appealing visual identity that reflects the brand's essence.

            8.  **Positioning Statement:**
                *   Write a clear and concise statement defining the brand's unique value proposition and position in the market relative to competitors (even if not explicitly named) for its specific target audience.

            9.  **Key Messages (3-4):**
                *   List the core messages the brand should consistently communicate across all touchpoints. These should be benefit-oriented and derived from the positioning statement.

            10. **Voice & Tone (3-5 keywords + description):**
                *   List keywords describing the desired brand voice (e.g., "Innovative," "Trustworthy," "Playful," "Authoritative").
                *   Add a brief description elaborating on how this voice and tone should manifest in communication.

            ---

            **Output Format:**
            Strictly format your entire response as a single, valid JSON object. Adhere precisely to the following Pydantic model structure (do not include markdown code fences ```json or ```):

            ```json
            {{
                "brand_name_suggestions": [
                    {{"value": "Name1", "rationale": "Rationale text..."}},
                    {{"value": "Name2", "rationale": "Rationale text..."}}
                ],
                "tagline_suggestions": [
                    {{"value": "Tagline1", "rationale": "Rationale text..."}},
                    {{"value": "Tagline2", "rationale": "Rationale text..."}}
                ],
                "selected_brand_name": {{"value": "Selected Name", "justification": "Justification text..."}},
                "selected_tagline": {{"value": "Selected Tagline", "justification": "Justification text..."}},
                "color_scheme": {{
                    "primary": "#XXXXXX",
                    "secondary": "#XXXXXX",
                    "accent": "#XXXXXX",
                    "background": "#XXXXXX",
                    "text": "#XXXXXX",
                    "rationale": "Detailed rationale connecting colors to brand psychology, audience, and concept..."
                }},
                "logo_concepts": [
                    {{"description": "Detailed concept description 1", "message": "Feeling/Message text..."}},
                    {{"description": "Detailed concept description 2", "message": "Feeling/Message text..."}}
                ],
                "visual_identity_rationale": "Overall rationale explaining synergy between colors and logo concepts...",
                "positioning_statement": "Positioning statement text...",
                "key_messages": ["Benefit-oriented message 1", "Benefit-oriented message 2", "Benefit-oriented message 3"],
                "voice_tone": {{
                    "keywords": ["Keyword1", "Keyword2", "Keyword3"],
                    "description": "Brief description elaborating on the voice/tone..."
                }}
            }}
            ```

            Ensure all fields are populated according to the instructions above. The output MUST be only the JSON object.
            """

            # Call LLM
            logger.info("Sending request to LLM for branding generation.")
            llm_response_text = await self.llm_client.generate_text_async(prompt=prompt)

            # Parse LLM Response
            try:
                # Clean potential markdown code fences
                if llm_response_text.strip().startswith("```json"):
                    llm_response_text = llm_response_text.strip()[7:-3].strip()
                elif llm_response_text.strip().startswith("```"):
                    llm_response_text = llm_response_text.strip()[3:-3].strip()

                llm_data = json.loads(llm_response_text)
                logger.info("Successfully parsed LLM response JSON.")
            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse LLM response as JSON: {e}")
                return {
                    "success": False,
                    "error": f"Failed to parse LLM response as JSON: {str(e)}"
                }

            # Perform Availability Checks
            availability_notes: Dict[str, str] = {}
            availability_statuses: Dict[str, str] = {}

            brand_suggestions = llm_data.get("brand_name_suggestions", [])
            suggested_names = [s.get("value") for s in brand_suggestions if s.get("value")]

            if suggested_names:
                logger.info(f"Checking availability for suggested names: {suggested_names}")

                # Check availability for each name
                for name in suggested_names:
                    summary, status = await self._check_name_availability(name)
                    availability_notes[name] = summary
                    availability_statuses[name] = status

                logger.info(f"Availability check statuses: {availability_statuses}")

            # Analyze Availability and Select Final Name
            original_selected_name_item = llm_data.get("selected_brand_name", {})
            original_selected_name = original_selected_name_item.get("value")
            final_selected_name_item = original_selected_name_item # Default to original

            if original_selected_name and original_selected_name in availability_statuses:
                original_status = availability_statuses[original_selected_name]
                logger.info(f"Original LLM selected name '{original_selected_name}' has availability status: {original_status}")

                # If original selection is not ideal ('available'), try to find a better one
                if original_status != 'available':
                    logger.info(f"Original selection '{original_selected_name}' is not 'available'. Searching for alternatives.")
                    found_available_alternative = False

                    # Iterate through suggestions IN THE ORDER PROVIDED BY LLM
                    for suggestion_item in brand_suggestions:
                        suggestion_name = suggestion_item.get("value")
                        if suggestion_name and suggestion_name in availability_statuses:
                            suggestion_status = availability_statuses[suggestion_name]
                            if suggestion_status == 'available':
                                logger.info(f"Found 'available' alternative: '{suggestion_name}'. Selecting it.")
                                # Use the original rationale from the suggestion
                                original_rationale = suggestion_item.get("rationale", "No rationale provided.")
                                final_selected_name_item = {
                                    "value": suggestion_name,
                                    "justification": f"Selected based on availability ('{suggestion_status}'). Original rationale: {original_rationale}"
                                }
                                found_available_alternative = True
                                break # Stop after finding the first available alternative

                    if not found_available_alternative:
                        logger.warning(f"Could not find an 'available' alternative. Keeping original selection '{original_selected_name}' despite status '{original_status}'.")
                        # Optionally update justification to mention availability issue
                        final_selected_name_item["justification"] = f"{original_selected_name_item.get('justification', '')} (Availability Status: {original_status})"

            # Update llm_data with the potentially revised selection
            llm_data["selected_brand_name"] = final_selected_name_item

            # Validate and Assemble Final Brand Package
            try:
                # Add target demographics back into the package if not already present
                if 'target_demographics' not in llm_data:
                    llm_data['target_demographics'] = inputs.target_audience

                # Validate the main structure
                brand_package = BrandPackage(**llm_data)
                # Add the availability notes
                brand_package.availability_notes = availability_notes
                logger.info("Successfully validated LLM data and added availability notes.")

                # Return the brand package
                return {
                    "success": True,
                    "message": "Brand identity generated successfully.",
                    **brand_package.model_dump()
                }
            except Exception as e:
                logger.error(f"LLM response data failed validation: {e}")
                return {
                    "success": False,
                    "error": f"LLM response data failed validation: {str(e)}",
                    "partial_data": llm_data
                }

        except Exception as e:
            logger.error(f"Error generating brand identity: {e}", exc_info=True)
            return {
                "success": False,
                "error": f"Error generating brand identity: {str(e)}"
            }

    @skill(
        name="check_name_availability",
        description="Check domain, social, and trademark availability for a brand name",
        tags=["branding", "availability"]
    )
    async def check_name_availability_skill(self, name: str) -> Dict[str, Any]:
        """
        Check domain, social, and trademark availability for a brand name.

        Args:
            name: The brand name to check.

        Returns:
            A dictionary containing the availability check results.
        """
        logger.info(f"Checking availability for brand name: {name}")

        try:
            summary, status = await self._check_name_availability(name)

            return {
                "success": True,
                "name": name,
                "status": status,
                "summary": summary
            }
        except Exception as e:
            logger.error(f"Error checking name availability: {e}", exc_info=True)
            return {
                "success": False,
                "name": name,
                "error": f"Error checking name availability: {str(e)}"
            }

    async def run_async(self, context: InvocationContext) -> Event:
        """
        Executes the branding generation workflow asynchronously according to ADK spec.
        Maintained for backward compatibility with ADK.

        Args:
            context: The invocation context containing the input data.

        Returns:
            An Event containing the branding results or an error.
        """
        logger.info(f"Received invocation for BrandingAgent (ID: {context.invocation_id})")

        try:
            # Extract input from context
            input_data = {}
            if hasattr(context, 'input') and hasattr(context.input, 'data'):
                if isinstance(context.input.data, dict):
                    input_data = context.input.data
                else:
                    try:
                        input_data = json.loads(context.input.data)
                    except json.JSONDecodeError as e:
                        logger.error(f"Input data is not a valid dictionary or JSON string: {context.input.data}")
                        raise ValueError(f"Input data is not a valid dictionary or JSON string: {e}") from e

            # Parse and validate input
            try:
                inputs = BrandingAgentInput(**input_data)
            except Exception as e:
                logger.error(f"Input validation failed: {e}")
                return Event(
                    event_type="adk.agent.error",
                    data={"error": "Input validation failed", "details": str(e)},
                    metadata={"status": "error"}
                )

            # Use the A2A skill
            result = await self.generate_brand(
                product_concept=inputs.product_concept,
                target_audience=inputs.target_audience,
                keywords=inputs.keywords,
                business_model_type=inputs.business_model_type
            )

            # Create an event from the result
            if result.get("success", False):
                return Event(
                    event_type="adk.agent.result",
                    data={k: v for k, v in result.items() if k != "success" and k != "message"},
                    metadata={"status": "success"}
                )
            else:
                return Event(
                    event_type="adk.agent.error",
                    data={"error": result.get("error", "Branding generation failed.")},
                    metadata={"status": "error"}
                )

        except Exception as e:
            # Catch-all for unexpected errors
            logger.error(f"Unexpected error in BrandingAgent: {e}", exc_info=True)
            return Event(
                event_type="adk.agent.error",
                data={"error": "Internal Agent Error", "details": f"An unexpected error occurred: {str(e)}"},
                metadata={"status": "error"}
            )

# Example of how to run this agent as a standalone A2A server
if __name__ == "__main__":
    # Create the agent
    agent = BrandingAgent()

    # Run the A2A server
    agent.run_server(host="0.0.0.0", port=agent.port or 8006)