import os
import random
import string
import httpx
import asyncio
import json # Added for potential context data parsing
from typing import Dict, List, Any, Optional
from pydantic import BaseModel, Field

# Import ADK components
from google.adk.agents import LlmAgent
from google.adk.runtime import InvocationContext
from google.adk.runtime.events import Event

# Assuming ImprovedProductSpec structure is available or defined elsewhere
# Define input based on what BrandingAgent needs from ImprovedProductSpec
class BrandingAgentInput(BaseModel):
    """Input for the Branding Agent."""
    product_concept: str = Field(description="Description of the core product/model.")
    target_audience: List[str] = Field(description="Defined target demographics.")
    keywords: Optional[List[str]] = Field(None, description="Optional keywords related to the product/concept.")
    business_model_type: Optional[str] = Field(None, description="Optional: Type of business model (e.g., 'saas', 'e-commerce') to guide branding.")

# Define output based on the architecture plan and LLM generation
class ColorScheme(BaseModel):
    """Represents a suggested color scheme."""
    primary: str = Field(description="Primary color hex code (e.g., '#4A90E2')")
    secondary: str = Field(description="Secondary color hex code")
    accent: str = Field(description="Accent color hex code")
    background: str = Field(description="Background color hex code (often light/dark)")
    text: str = Field(description="Text color hex code (contrast with background)")
    rationale: str = Field(description="Explanation for the color choices")

# Define structured suggestions
class Suggestion(BaseModel):
    """Represents a suggestion with its rationale."""
    value: str = Field(description="The suggested item (e.g., brand name, tagline).")
    rationale: str = Field(description="The reasoning behind the suggestion.")

class SelectedItem(BaseModel):
    """Represents a selected item with its justification."""
    value: str = Field(description="The selected item.")
    justification: str = Field(description="The reason for selecting this item.")

class LogoConcept(BaseModel):
    """Represents a logo concept description with its intended message."""
    description: str = Field(description="Detailed description of the logo concept/style.")
    message: str = Field(description="The feeling or message the concept aims to convey.")

class VoiceTone(BaseModel):
    """Represents the brand's voice and tone."""
    keywords: List[str] = Field(description="Keywords describing the desired brand voice.")
    description: str = Field(description="Brief description elaborating on the voice/tone.")


class BrandPackage(BaseModel):
    """Output schema for the Branding Agent, generated by an LLM."""
    brand_name_suggestions: List[Suggestion] = Field(description="List of suggested brand names with rationales.")
    tagline_suggestions: List[Suggestion] = Field(description="List of suggested taglines/slogans with rationales.")
    selected_brand_name: SelectedItem = Field(description="The primary recommended brand name with justification.")
    selected_tagline: SelectedItem = Field(description="The primary recommended tagline with justification.")
    color_scheme: ColorScheme = Field(description="Suggested color scheme with rationale.")
    logo_concepts: List[LogoConcept] = Field(description="Descriptions of potential logo concepts/styles with intended messages.")
    visual_identity_rationale: str = Field(description="Overall rationale for the visual identity direction (colors, logo ideas).")
    positioning_statement: str = Field(description="Statement defining the brand's market position.")
    key_messages: List[str] = Field(description="Core messages the brand should communicate.")
    voice_tone: VoiceTone = Field(description="Description of the desired brand voice and tone.")
    target_demographics: List[str] = Field(description="Target demographics provided as input.", default=[]) # Keep from input, add default
    availability_notes: Optional[Dict[str, str]] = Field(None, description="Summary of availability checks for suggested names (domain, social, trademark).")

# --- Agent Class ---

class BrandingAgent(LlmAgent): # Inherit from LlmAgent
    """
    ADK Agent responsible for Stage 3: Rebranding.
    Generates a brand identity based on the improved product specification.
    """
    def __init__(self,
                 agent_id: str = "branding_agent",
                 model_name: Optional[str] = None, # Added model_name parameter
                 web_search_agent_url: Optional[str] = None):
        """
        Initialize the Branding Agent.

        Args:
            agent_id: The unique identifier for this agent instance.
            model_name: The name of the Gemini model to use (e.g., 'gemini-1.5-flash-latest').
                        Defaults to a suitable model if None.
            web_search_agent_url: The URL for the WebSearchAgent A2A endpoint.
        """
        # Determine the model name to use
        effective_model_name = model_name if model_name else 'gemini-1.5-flash-latest' # Default for specialized agent
        self.model_name = effective_model_name # Store the actual model name used

        # Initialize the ADK Gemini model
        # Note: Assumes GEMINI_API_KEY is configured globally for ADK or handled by LlmAgent
        adk_model = Gemini(model=self.model_name)

        # Call super().__init__ from LlmAgent, passing the model
        super().__init__(
            agent_id=agent_id,
            model=adk_model # Pass the initialized ADK model object
            # instruction can be set here if needed, or rely on default/prompt
        )

        self.web_search_agent_url = web_search_agent_url or os.getenv("WEB_SEARCH_AGENT_URL")
        self.brave_api_key = os.getenv("BRAVE_API_KEY")

        if not self.web_search_agent_url:
            self.logger.warning("WEB_SEARCH_AGENT_URL is not configured. Availability checks will be skipped.")
        if not self.brave_api_key:
            # Log warning, but allow continuation if only URL is missing (maybe search works without API key for some basic checks?)
            # Or raise an error if API key is absolutely essential for the WebSearchAgent. Let's warn for now.
            self.logger.warning("BRAVE_API_KEY is not configured. Web search functionality might be limited or fail.")
        self.logger.info(f"BrandingAgent initialized with model: {self.model_name}") # Added logging for model

    async def _check_name_availability(self, name: str, client: httpx.AsyncClient) -> tuple[str, str]:
        """
        Checks domain, social, and potentially trademark availability for a given name.
        Returns a tuple: (summary_string, availability_status).
        Status can be 'available', 'likely_taken', 'uncertain', 'error', or 'skipped'.
        """
        if not self.web_search_agent_url or not self.brave_api_key:
            self.logger.warning(f"Skipping availability check for '{name}' due to missing configuration.")
            return "Availability check skipped (missing configuration).", "skipped"

        # Simple check for common TLDs - more sophisticated checks might be needed
        domain_query = f"Is the domain name {name.replace(' ', '').lower()}.com available?"
        social_query = f"Are social media handles for '{name}' available on major platforms (Twitter, Instagram, Facebook)?"
        # Trademark check is complex, a simple search might just look for existing usage
        trademark_query = f"Are there existing trademarks or widely known brands called '{name}'?"

        queries = {
            "domain": domain_query,
            "social": social_query,
            "trademark": trademark_query
        }
        results = {}
        raw_search_details = {} # Store snippets for summary

        async def perform_search(query_type: str, query: str):
            search_url = f"{self.web_search_agent_url}/a2a/web_search/invoke"
            payload = {
                "input": {
                    "event_type": "adk.agent.invoke",
                    "data": {"query": query},
                    "metadata": {"brave_api_key": self.brave_api_key} # Pass API key in metadata
                },
                "invocation_id": f"branding-search-{name.replace(' ', '-')}-{query_type}-{random.randint(1000, 9999)}",
                "agent_id": "web_search_agent"
            }
            try:
                self.logger.info(f"Sending search request for '{name}' ({query_type}) to {search_url}")
                response = await client.post(search_url, json=payload, timeout=30.0)
                response.raise_for_status() # Raise HTTPStatusError for bad responses (4xx or 5xx)
                event_data = response.json()
                self.logger.debug(f"Received search response for '{name}' ({query_type}): {event_data}")

                if event_data.get("event_type") == "adk.agent.result" and isinstance(event_data.get("data"), dict):
                    # Extract relevant info - structure depends on WebSearchAgent's output
                    # Assuming 'summary' or 'results' field contains the answer
                    search_result = event_data["data"].get("summary") or event_data["data"].get("results", "No specific result found.")
                    # Basic interpretation (can be improved)
                    raw_search_details[query_type] = f"{search_result[:150]}..." # Store for summary
                    if "available" in str(search_result).lower() and "not available" not in str(search_result).lower():
                        results[query_type] = "Likely Available"
                    elif "not available" in str(search_result).lower() or "taken" in str(search_result).lower():
                        results[query_type] = "Likely Unavailable"
                    else:
                        results[query_type] = "Unclear/Check Manually"
                elif event_data.get("event_type") == "adk.agent.error":
                     self.logger.error(f"WebSearchAgent returned error for '{name}' ({query_type}): {event_data.get('data')}")
                     results[query_type] = "Error during check"
                     raw_search_details[query_type] = "Error during check."
                else:
                    self.logger.warning(f"Unexpected event type from WebSearchAgent for '{name}' ({query_type}): {event_data.get('event_type')}")
                    results[query_type] = "Unknown response format"
                    raw_search_details[query_type] = "Unknown response format."

            except httpx.HTTPStatusError as e:
                self.logger.error(f"HTTP error calling WebSearchAgent for '{name}' ({query_type}): {e.response.status_code} - {e.response.text}")
                results[query_type] = f"HTTP Error ({e.response.status_code})"
                raw_search_details[query_type] = f"HTTP Error ({e.response.status_code})."
            except httpx.RequestError as e:
                self.logger.error(f"Request error calling WebSearchAgent for '{name}' ({query_type}): {e}")
                results[query_type] = "Request Error"
                raw_search_details[query_type] = "Request Error."
            except Exception as e:
                self.logger.error(f"Unexpected error during web search for '{name}' ({query_type}): {e}", exc_info=True)
                results[query_type] = "Unexpected Error"
                raw_search_details[query_type] = "Unexpected Error."

        # Run searches concurrently
        tasks = [perform_search(q_type, q_text) for q_type, q_text in queries.items()]
        await asyncio.gather(*tasks)

        # Format summary string including raw details
        summary_str = (
            f"Domain: {results.get('domain', 'N/A')} ({raw_search_details.get('domain', 'N/A')}). "
            f"Social: {results.get('social', 'N/A')} ({raw_search_details.get('social', 'N/A')}). "
            f"Trademark: {results.get('trademark', 'N/A')} ({raw_search_details.get('trademark', 'N/A')})"
        )
        self.logger.info(f"Availability check summary for '{name}': {summary_str}")

        # Determine overall status
        domain_status = results.get('domain')
        social_status = results.get('social')
        trademark_status = results.get('trademark')

        if any(s and 'Error' in s for s in results.values()):
            status = 'error'
        elif domain_status == "Likely Unavailable" or trademark_status == "Likely Unavailable":
            status = 'likely_taken'
        elif domain_status == "Likely Available" and social_status != "Likely Unavailable":
            # Prioritize domain availability, allow social to be unclear/taken if domain is good
            status = 'available'
        else: # Covers cases where domain is unclear, or domain is available but social is unavailable etc.
            status = 'uncertain'

        self.logger.info(f"Determined availability status for '{name}': {status}")
        return summary_str, status


    async def run_async(self, context: InvocationContext) -> Event:
        """Executes the branding generation workflow using an LLM."""
        self.logger.info(f"Starting LLM-based branding generation for context: {context.invocation_id}")

        try:
            # 1. Parse Input from context
            if not isinstance(context.input.data, dict):
                try:
                    input_data = json.loads(context.input.data)
                except json.JSONDecodeError as e:
                    self.logger.error(f"Input data is not a valid dictionary or JSON string: {context.input.data}")
                    raise ValueError(f"Input data is not a valid dictionary or JSON string: {e}") from e
            else:
                input_data = context.input.data

            # Validate input using Pydantic model
            try:
                inputs = BrandingAgentInput(**input_data)
                self.logger.info(f"Parsed input: Concept='{inputs.product_concept}', Audience='{inputs.target_audience}', Keywords='{inputs.keywords}', Model='{inputs.business_model_type}'")
            except Exception as e: # Catch Pydantic validation errors
                 self.logger.error(f"Input validation failed: {e}. Input data: {input_data}")
                 raise ValueError(f"Input validation failed: {e}") from e

            # 2. Construct LLM Prompt
            # --- Enhanced LLM Prompt ---
            # This prompt is designed to elicit more creative, detailed, and relevant branding elements.
            # It emphasizes deep consideration of the input and asks for rationales.
            prompt = f"""
            You are a highly creative and strategic branding expert tasked with developing a compelling brand identity.
            Deeply analyze the provided product specification:

            **Core Product Concept:**
            {inputs.product_concept}

            **Target Audience:**
            {', '.join(inputs.target_audience)}

            **Keywords (if any):**
            {', '.join(inputs.keywords) if inputs.keywords else 'None provided'}

            **Business Model Type (if specified):**
            {inputs.business_model_type or 'Not specified'}

            ---

            **Your Task:** Generate a comprehensive and creative branding package. Ensure all elements are consistent and reinforce a unified brand identity.

            **Required Branding Elements:**

            1.  **Brand Name Suggestions (3-5):**
                *   Generate a diverse list of creative, memorable, and relevant brand names.
                *   Consider different styles (e.g., descriptive, evocative, abstract, invented).
                *   Briefly explain the rationale and relevance of *each* suggestion in relation to the product concept and target audience.

            2.  **Tagline Suggestions (3-5):**
                *   Generate catchy, impactful taglines/slogans.
                *   Each tagline should strongly align with the product's core value proposition and resonate with the target audience.
                *   Briefly explain the rationale for *each* tagline.

            3.  **Selected Brand Name:**
                *   Choose the *single strongest* brand name from your suggestions. Justify your choice.

            4.  **Selected Tagline:**
                *   Choose the *single strongest* tagline from your suggestions. Justify your choice.

            5.  **Color Scheme:**
                *   Suggest a cohesive color scheme including primary, secondary, accent, background (light/dark), and text hex codes.
                *   Provide a detailed rationale explaining the psychological impact of the color choices and how they align with the brand's desired image, product concept, and target audience.

            6.  **Logo Concepts (2-3):**
                *   Describe distinct and evocative concepts or styles for a logo (e.g., "Geometric wordmark using a modern, bold sans-serif font, conveying stability and innovation", "Abstract icon symbolizing [key concept] with fluid lines, suggesting adaptability").
                *   Go beyond simple descriptions; explain the *feeling* or *message* each concept aims to convey.

            7.  **Visual Identity Rationale:**
                *   Provide a concise summary explaining how the suggested color scheme and logo concepts work together to create a cohesive and appealing visual identity that reflects the brand's essence.

            8.  **Positioning Statement:**
                *   Write a clear and concise statement defining the brand's unique value proposition and position in the market relative to competitors (even if not explicitly named) for its specific target audience.

            9.  **Key Messages (3-4):**
                *   List the core messages the brand should consistently communicate across all touchpoints. These should be benefit-oriented and derived from the positioning statement.

            10. **Voice & Tone (3-5 keywords + description):**
                *   List keywords describing the desired brand voice (e.g., "Innovative," "Trustworthy," "Playful," "Authoritative").
                *   Add a brief description elaborating on how this voice and tone should manifest in communication.

            ---

            **Output Format:**
            Strictly format your entire response as a single, valid JSON object. Adhere precisely to the following Pydantic model structure (do not include markdown code fences ```json or ```):

            ```json
            {{
                "brand_name_suggestions": [
                    {{"value": "Name1", "rationale": "Rationale text..."}},
                    {{"value": "Name2", "rationale": "Rationale text..."}}
                ],
                "tagline_suggestions": [
                    {{"value": "Tagline1", "rationale": "Rationale text..."}},
                    {{"value": "Tagline2", "rationale": "Rationale text..."}}
                ],
                "selected_brand_name": {{"value": "Selected Name", "justification": "Justification text..."}},
                "selected_tagline": {{"value": "Selected Tagline", "justification": "Justification text..."}},
                "color_scheme": {{
                    "primary": "#XXXXXX",
                    "secondary": "#XXXXXX",
                    "accent": "#XXXXXX",
                    "background": "#XXXXXX",
                    "text": "#XXXXXX",
                    "rationale": "Detailed rationale connecting colors to brand psychology, audience, and concept..."
                }},
                "logo_concepts": [
                    {{"description": "Detailed concept description 1", "message": "Feeling/Message text..."}},
                    {{"description": "Detailed concept description 2", "message": "Feeling/Message text..."}}
                ],
                "visual_identity_rationale": "Overall rationale explaining synergy between colors and logo concepts...",
                "positioning_statement": "Positioning statement text...",
                "key_messages": ["Benefit-oriented message 1", "Benefit-oriented message 2", "Benefit-oriented message 3"],
                "voice_tone": {{
                    "keywords": ["Keyword1", "Keyword2", "Keyword3"],
                    "description": "Brief description elaborating on the voice/tone..."
                }}
            }}
            ```

            Ensure all fields are populated according to the instructions above. The output MUST be only the JSON object.
            """

            # 3. Call LLM
            self.logger.info("Sending request to LLM for branding generation.")
            llm_response_text = await self.llm_client.generate_text_async(prompt=prompt)
            self.logger.debug(f"Raw LLM response: {llm_response_text}") # Log raw response for debugging

            # 4. Parse LLM Response
            try:
                # Clean potential markdown code fences
                if llm_response_text.strip().startswith("```json"):
                    llm_response_text = llm_response_text.strip()[7:-3].strip()
                elif llm_response_text.strip().startswith("```"):
                     llm_response_text = llm_response_text.strip()[3:-3].strip()

                llm_data = json.loads(llm_response_text)
                self.logger.info("Successfully parsed LLM response JSON.")
            except json.JSONDecodeError as e:
                self.logger.error(f"Failed to parse LLM response as JSON: {e}. Response: {llm_response_text}")
                raise ValueError(f"LLM response was not valid JSON: {e}") from e
            except Exception as e: # Catch other potential errors during parsing
                self.logger.error(f"An unexpected error occurred during LLM response parsing: {e}. Response: {llm_response_text}")
                raise ValueError(f"Could not process LLM response: {e}") from e


            # 5. Perform Availability Checks (if configured)
            availability_notes: Dict[str, str] = {}
            availability_statuses: Dict[str, str] = {}
            suggested_names_map: Dict[str, Dict] = {} # Map name to original suggestion dict

            if self.web_search_agent_url and self.brave_api_key:
                brand_suggestions = llm_data.get("brand_name_suggestions", [])
                suggested_names = [s.get("value") for s in brand_suggestions if s.get("value")]

                if not suggested_names:
                     self.logger.warning("No brand name suggestions found in LLM response to check availability.")
                else:
                    # Store original suggestions for later lookup
                    for suggestion in brand_suggestions:
                        if suggestion.get("value"):
                            suggested_names_map[suggestion["value"]] = suggestion

                    self.logger.info(f"Checking availability for suggested names: {suggested_names}")
                    async with httpx.AsyncClient() as client:
                        tasks = [self._check_name_availability(name, client) for name in suggested_names]
                        # results will be a list of tuples: [(summary1, status1), (summary2, status2), ...]
                        check_results = await asyncio.gather(*tasks)

                        # Populate notes and statuses dictionaries
                        for i, name in enumerate(suggested_names):
                            if i < len(check_results):
                                summary, status = check_results[i]
                                availability_notes[name] = summary
                                availability_statuses[name] = status
                            else:
                                # Should not happen if gather worked correctly, but handle defensively
                                availability_notes[name] = "Error retrieving check result."
                                availability_statuses[name] = "error"

                        self.logger.info(f"Availability check notes: {availability_notes}")
                        self.logger.info(f"Availability check statuses: {availability_statuses}")
            else:
                self.logger.info("Skipping availability checks as Web Search Agent URL or Brave API Key is not configured.")
                availability_notes = {"info": "Availability checks skipped due to missing configuration."}
                # Populate statuses as skipped for any suggested names
                for s in llm_data.get("brand_name_suggestions", []):
                    if s.get("value"):
                        availability_statuses[s["value"]] = "skipped"


            # 6. Analyze Availability and Select Final Name
            original_selected_name_item = llm_data.get("selected_brand_name", {})
            original_selected_name = original_selected_name_item.get("value")
            final_selected_name_item = original_selected_name_item # Default to original

            if original_selected_name and original_selected_name in availability_statuses:
                original_status = availability_statuses[original_selected_name]
                self.logger.info(f"Original LLM selected name '{original_selected_name}' has availability status: {original_status}")

                # If original selection is not ideal ('available'), try to find a better one
                if original_status != 'available':
                    self.logger.info(f"Original selection '{original_selected_name}' is not 'available'. Searching for alternatives.")
                    found_available_alternative = False
                    # Iterate through suggestions IN THE ORDER PROVIDED BY LLM
                    for suggestion_item in llm_data.get("brand_name_suggestions", []):
                        suggestion_name = suggestion_item.get("value")
                        if suggestion_name and suggestion_name in availability_statuses:
                            suggestion_status = availability_statuses[suggestion_name]
                            if suggestion_status == 'available':
                                self.logger.info(f"Found 'available' alternative: '{suggestion_name}'. Selecting it.")
                                # Use the original rationale from the suggestion
                                original_rationale = suggestion_item.get("rationale", "No rationale provided.")
                                final_selected_name_item = {
                                    "value": suggestion_name,
                                    "justification": f"Selected based on availability ('{suggestion_status}'). Original rationale: {original_rationale}"
                                }
                                found_available_alternative = True
                                break # Stop after finding the first available alternative

                    if not found_available_alternative:
                         self.logger.warning(f"Could not find an 'available' alternative. Keeping original selection '{original_selected_name}' despite status '{original_status}'.")
                         # Optionally update justification to mention availability issue
                         final_selected_name_item["justification"] = f"{original_selected_name_item.get('justification', '')} (Availability Status: {original_status})"

            else:
                 self.logger.warning(f"Could not determine availability status for originally selected name '{original_selected_name}'. Keeping original selection.")

            # Update llm_data with the potentially revised selection
            llm_data["selected_brand_name"] = final_selected_name_item


            # 7. Validate and Assemble Final Brand Package
            try:
                # Add target demographics back into the package if not already present
                if 'target_demographics' not in llm_data:
                     llm_data['target_demographics'] = inputs.target_audience

                # Validate the main structure first (using the potentially updated llm_data)
                brand_package = BrandPackage(**llm_data)
                # Add the availability notes (summary strings) collected separately
                brand_package.availability_notes = availability_notes
                self.logger.info("Successfully validated LLM data and added availability notes.")

            except Exception as e: # Catch Pydantic validation errors
                self.logger.error(f"LLM response data failed validation against BrandPackage model: {e}. Data: {llm_data}")
                # Consider logging the specific validation errors if Pydantic provides them easily
                raise ValueError(f"LLM response data failed validation: {e}") from e

            # 7. Return Success Event
            self.logger.info("Branding generation finished successfully.")
            return Event(
                event_type="adk.agent.result",
                data=brand_package.model_dump(), # Serialize the Pydantic model including notes
                metadata={"status": "success"}
            )

        except ValueError as ve: # Catch specific validation/parsing errors
             self.logger.error(f"BrandingAgent execution failed due to ValueError: {ve}", exc_info=True)
             return Event(
                 event_type="adk.agent.error",
                 data={"error": "Input or LLM Response Error", "details": str(ve)},
                 metadata={"status": "error"}
             )
        except Exception as e: # Catch broader errors (e.g., LLM client issues)
            self.logger.error(f"BrandingAgent execution failed unexpectedly: {e}", exc_info=True)
            return Event(
                event_type="adk.agent.error",
                data={"error": "Internal Agent Error", "details": f"An unexpected error occurred: {str(e)}"},
                metadata={"status": "error"}
            )

# Removed the old _load_branding_elements, _generate_brand_name, _generate_color_scheme, _generate_positioning methods
# Removed the if __name__ == "__main__": block