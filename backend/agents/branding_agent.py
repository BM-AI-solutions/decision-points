import asyncio
import json
import os
import argparse
from typing import Dict, List, Any, Optional

import httpx
import logfire
import uvicorn
from fastapi import FastAPI, HTTPException, Body
from pydantic import BaseModel, Field

# Import ADK components
# Assuming ADK is installed and configured (e.g., via requirements.txt and env vars)
from google.adk.agents import LlmAgent
from google.adk.llm import Gemini # Assuming Gemini is the intended LLM client
from google.adk.runtime import InvocationContext
from google.adk.runtime.events import Event

# --- Pydantic Models for Input/Output ---

class BrandingAgentInput(BaseModel):
    """Input for the Branding Agent."""
    product_concept: str = Field(description="Description of the core product/model.")
    target_audience: List[str] = Field(description="Defined target demographics.")
    keywords: Optional[List[str]] = Field(None, description="Optional keywords related to the product/concept.")
    business_model_type: Optional[str] = Field(None, description="Optional: Type of business model (e.g., 'saas', 'e-commerce') to guide branding.")

class ColorScheme(BaseModel):
    primary: str
    secondary: str
    accent: str
    background: str
    text: str
    rationale: str

class Suggestion(BaseModel):
    value: str
    rationale: str

class SelectedItem(BaseModel):
    value: str
    justification: str

class LogoConcept(BaseModel):
    description: str
    message: str

class VoiceTone(BaseModel):
    keywords: List[str]
    description: str

class BrandPackage(BaseModel):
    """Output schema for the Branding Agent, generated by an LLM."""
    brand_name_suggestions: List[Suggestion]
    tagline_suggestions: List[Suggestion]
    selected_brand_name: SelectedItem
    selected_tagline: SelectedItem
    color_scheme: ColorScheme
    logo_concepts: List[LogoConcept]
    visual_identity_rationale: str
    positioning_statement: str
    key_messages: List[str]
    voice_tone: VoiceTone
    target_demographics: List[str] = Field(default=[])
    availability_notes: Optional[Dict[str, str]] = None # Added by agent after checks

# --- Agent Class ---

class BrandingAgent(LlmAgent):
    """
    ADK Agent responsible for Stage 3: Rebranding.
    Generates a brand identity based on the improved product specification.
    """
    def __init__(self,
                 agent_id: str = "branding-agent",
                 model_name: Optional[str] = None,
                 web_search_agent_url: Optional[str] = None): # Changed from ID to URL
        """
        Initialize the Branding Agent.

        Args:
            agent_id: The unique identifier for this agent instance.
            model_name: The name of the Gemini model to use (e.g., 'gemini-1.5-flash-latest').
                        Defaults to 'gemini-1.5-flash-latest' if None.
            web_search_agent_url: The HTTP URL for the WebSearchAgent A2A endpoint.
        """
        # Get config from environment variables
        effective_model_name = model_name or os.environ.get('GEMINI_MODEL_NAME', 'gemini-1.5-flash-latest')
        self.model_name = effective_model_name
        self.web_search_agent_url = web_search_agent_url or os.environ.get('WEB_SEARCH_AGENT_URL')

        # Initialize the ADK Gemini model
        # Note: Assumes GEMINI_API_KEY is configured globally for ADK via environment variable
        try:
            adk_model = Gemini(model=self.model_name)
        except Exception as e:
            logfire.error(f"Failed to initialize Gemini model '{self.model_name}': {e}", exc_info=True)
            # Decide how to handle this - raise error, use a dummy model, etc.
            # For now, let the LlmAgent initialization potentially fail or handle it.
            adk_model = None # Or raise an error immediately

        # Call super().__init__ from LlmAgent, passing the model
        super().__init__(
            agent_id=agent_id,
            model=adk_model # Pass the initialized ADK model object
        )

        if not self.web_search_agent_url:
            self.logger.warning("WEB_SEARCH_AGENT_URL is not configured (checked constructor arg and env var). Availability checks will be skipped or fail.")
        else:
             self.logger.info(f"Using WebSearchAgent URL: {self.web_search_agent_url}")
        self.logger.info(f"BrandingAgent initialized with model: {self.model_name}")

    async def _check_name_availability(self, context: InvocationContext, name: str) -> tuple[str, str]:
        """
        Checks domain, social, and potentially trademark availability for a given name.
        Returns a tuple: (summary_string, availability_status).
        Status can be 'available', 'likely_taken', 'uncertain', 'error', or 'skipped'.

        *** NOTE: This method needs refactoring for A2A. ***
        The current implementation uses context.invoke_skill, which is not suitable
        for HTTP-based A2A communication. It should be updated to use an HTTP client
        (like httpx) to call self.web_search_agent_url.
        For now, it will likely fail if called.
        """
        self.logger.warning(f"Attempting availability check for '{name}' using outdated invoke_skill method. This needs refactoring for A2A.")

        if not self.web_search_agent_url: # Check URL now, not ID
            self.logger.warning(f"Skipping availability check for '{name}' due to missing WEB_SEARCH_AGENT_URL configuration.")
            return "Availability check skipped (missing configuration).", "skipped"

        # --- Start of section needing A2A refactor ---
        # The following code uses context.invoke_skill and assumes a different
        # communication mechanism than the A2A HTTP server being set up.

        # Example of how it *should* work with A2A (pseudo-code):
        # try:
        #     async with httpx.AsyncClient() as client:
        #         response = await client.post(
        #             f"{self.web_search_agent_url}/invoke", # Assuming /invoke endpoint
        #             json={"query": f"Is domain {name}.com available?"},
        #             timeout=30.0
        #         )
        #         response.raise_for_status()
        #         result_data = response.json()
        #         # Process result_data...
        #         results["domain"] = "Processed result"
        #         raw_search_details["domain"] = "Snippet from result"
        # except Exception as e:
        #     # Handle errors...
        #     results["domain"] = "Error during check"
        #     raw_search_details["domain"] = f"Error: {e}"

        # --- For now, returning 'skipped' as the old logic won't work ---
        self.logger.error(f"Availability check for '{name}' cannot proceed without A2A refactoring of _check_name_availability.")
        return "Availability check skipped (A2A refactor needed).", "skipped"
        # --- End of section needing A2A refactor ---


    async def run_async(self, context: InvocationContext) -> Event:
        """Executes the branding generation workflow using an LLM."""
        self.logger.info(f"Starting LLM-based branding generation for context: {context.invocation_id}")

        try:
            # 1. Parse Input from context data
            if not isinstance(context.data, dict):
                 self.logger.error(f"Input data is not a dictionary: {context.data}")
                 raise ValueError("Input data must be a dictionary for BrandingAgent.")

            # Validate input using Pydantic model
            try:
                inputs = BrandingAgentInput(**context.data)
                self.logger.info(f"Parsed input: Concept='{inputs.product_concept}', Audience='{inputs.target_audience}', Keywords='{inputs.keywords}', Model='{inputs.business_model_type}'")
            except Exception as e: # Catch Pydantic validation errors
                 self.logger.error(f"Input validation failed: {e}. Input data: {context.data}")
                 raise ValueError(f"Input validation failed: {e}") from e

            # 2. Construct LLM Prompt (using the detailed prompt from previous version)
            prompt = f"""
            You are a highly creative and strategic branding expert tasked with developing a compelling brand identity.
            Deeply analyze the provided product specification:

            **Core Product Concept:**
            {inputs.product_concept}

            **Target Audience:**
            {', '.join(inputs.target_audience)}

            **Keywords (if any):**
            {', '.join(inputs.keywords) if inputs.keywords else 'None provided'}

            **Business Model Type (if specified):**
            {inputs.business_model_type or 'Not specified'}

            ---

            **Your Task:** Generate a comprehensive and creative branding package. Ensure all elements are consistent and reinforce a unified brand identity.

            **Required Branding Elements:**

            1.  **Brand Name Suggestions (3-5):**
                *   Generate a diverse list of creative, memorable, and relevant brand names.
                *   Consider different styles (e.g., descriptive, evocative, abstract, invented).
                *   Briefly explain the rationale and relevance of *each* suggestion in relation to the product concept and target audience.

            2.  **Tagline Suggestions (3-5):**
                *   Generate catchy, impactful taglines/slogans.
                *   Each tagline should strongly align with the product's core value proposition and resonate with the target audience.
                *   Briefly explain the rationale for *each* tagline.

            3.  **Selected Brand Name:**
                *   Choose the *single strongest* brand name from your suggestions. Justify your choice.

            4.  **Selected Tagline:**
                *   Choose the *single strongest* tagline from your suggestions. Justify your choice.

            5.  **Color Scheme:**
                *   Suggest a cohesive color scheme including primary, secondary, accent, background (light/dark), and text hex codes.
                *   Provide a detailed rationale explaining the psychological impact of the color choices and how they align with the brand's desired image, product concept, and target audience.

            6.  **Logo Concepts (2-3):**
                *   Describe distinct and evocative concepts or styles for a logo (e.g., "Geometric wordmark using a modern, bold sans-serif font, conveying stability and innovation", "Abstract icon symbolizing [key concept] with fluid lines, suggesting adaptability").
                *   Go beyond simple descriptions; explain the *feeling* or *message* each concept aims to convey.

            7.  **Visual Identity Rationale:**
                *   Provide a concise summary explaining how the suggested color scheme and logo concepts work together to create a cohesive and appealing visual identity that reflects the brand's essence.

            8.  **Positioning Statement:**
                *   Write a clear and concise statement defining the brand's unique value proposition and position in the market relative to competitors (even if not explicitly named) for its specific target audience.

            9.  **Key Messages (3-4):**
                *   List the core messages the brand should consistently communicate across all touchpoints. These should be benefit-oriented and derived from the positioning statement.

            10. **Voice & Tone (3-5 keywords + description):**
                *   List keywords describing the desired brand voice (e.g., "Innovative," "Trustworthy," "Playful," "Authoritative").
                *   Add a brief description elaborating on how this voice and tone should manifest in communication.

            ---

            **Output Format:**
            Strictly format your entire response as a single, valid JSON object. Adhere precisely to the following Pydantic model structure (do not include markdown code fences ```json or ```):

            ```json
            {{
                "brand_name_suggestions": [
                    {{"value": "Name1", "rationale": "Rationale text..."}},
                    {{"value": "Name2", "rationale": "Rationale text..."}}
                ],
                "tagline_suggestions": [
                    {{"value": "Tagline1", "rationale": "Rationale text..."}},
                    {{"value": "Tagline2", "rationale": "Rationale text..."}}
                ],
                "selected_brand_name": {{"value": "Selected Name", "justification": "Justification text..."}},
                "selected_tagline": {{"value": "Selected Tagline", "justification": "Justification text..."}},
                "color_scheme": {{
                    "primary": "#XXXXXX",
                    "secondary": "#XXXXXX",
                    "accent": "#XXXXXX",
                    "background": "#XXXXXX",
                    "text": "#XXXXXX",
                    "rationale": "Detailed rationale connecting colors to brand psychology, audience, and concept..."
                }},
                "logo_concepts": [
                    {{"description": "Detailed concept description 1", "message": "Feeling/Message text..."}},
                    {{"description": "Detailed concept description 2", "message": "Feeling/Message text..."}}
                ],
                "visual_identity_rationale": "Overall rationale explaining synergy between colors and logo concepts...",
                "positioning_statement": "Positioning statement text...",
                "key_messages": ["Benefit-oriented message 1", "Benefit-oriented message 2", "Benefit-oriented message 3"],
                "voice_tone": {{
                    "keywords": ["Keyword1", "Keyword2", "Keyword3"],
                    "description": "Brief description elaborating on the voice/tone..."
                }}
            }}
            ```

            Ensure all fields are populated according to the instructions above. The output MUST be only the JSON object.
            """

            # 3. Call LLM
            if not self.llm_client:
                 self.logger.error("LLM client is not initialized. Cannot generate branding.")
                 raise RuntimeError("LLM client not initialized. Check model initialization and API key.")

            self.logger.info("Sending request to LLM for branding generation.")
            # Use the generate method provided by LlmAgent base class
            llm_response_event = await self.generate(prompt=prompt, output_schema=BrandPackage)
            self.logger.debug(f"Raw LLM response event: {llm_response_event}")

            if llm_response_event.type == "error":
                error_details = llm_response_event.data.get("details", "Unknown LLM error")
                self.logger.error(f"LLM generation failed: {error_details}")
                raise RuntimeError(f"LLM generation failed: {error_details}")

            # The LlmAgent's generate method should ideally return data already parsed
            # according to the output_schema if successful.
            llm_data = llm_response_event.data
            if not isinstance(llm_data, dict):
                 # If it's not a dict, maybe it's a Pydantic model already?
                 if hasattr(llm_data, 'model_dump'):
                     llm_data = llm_data.model_dump()
                 else:
                    self.logger.error(f"LLM response data is not a dictionary or Pydantic model: {type(llm_data)}")
                    raise ValueError("LLM response data format is unexpected.")

            self.logger.info("Successfully received and parsed LLM response.")


            # 4. Perform Availability Checks (using the placeholder/failing method for now)
            availability_notes: Dict[str, str] = {}
            availability_statuses: Dict[str, str] = {}

            if self.web_search_agent_url:
                brand_suggestions = llm_data.get("brand_name_suggestions", [])
                suggested_names = [s.get("value") for s in brand_suggestions if s.get("value")]

                if suggested_names:
                    self.logger.info(f"Checking availability for suggested names: {suggested_names} (Note: Check logic needs A2A refactor)")
                    # This call will currently return 'skipped' due to the note above
                    check_results = await asyncio.gather(
                        *[self._check_name_availability(context, name) for name in suggested_names]
                    )
                    for i, name in enumerate(suggested_names):
                        if i < len(check_results):
                            summary, status = check_results[i]
                            availability_notes[name] = summary
                            availability_statuses[name] = status
                        else:
                            availability_notes[name] = "Error retrieving check result."
                            availability_statuses[name] = "error"
                    self.logger.info(f"Availability check notes (requires A2A refactor): {availability_notes}")
                else:
                    self.logger.warning("No brand name suggestions found in LLM response to check availability.")
            else:
                self.logger.info("Skipping availability checks as Web Search Agent URL is not configured.")
                availability_notes = {"info": "Availability checks skipped due to missing configuration."}
                for s in llm_data.get("brand_name_suggestions", []):
                    if s.get("value"):
                        availability_statuses[s["value"]] = "skipped"


            # 5. Analyze Availability and Select Final Name (using potentially incomplete statuses)
            original_selected_name_item = llm_data.get("selected_brand_name", {})
            original_selected_name = original_selected_name_item.get("value")
            final_selected_name_item = original_selected_name_item # Default

            if original_selected_name and original_selected_name in availability_statuses:
                original_status = availability_statuses[original_selected_name]
                self.logger.info(f"Original LLM selected name '{original_selected_name}' has availability status: {original_status} (Note: Status based on incomplete check)")
                # Keep original selection logic, but be aware status might be 'skipped' or 'error'
                if original_status != 'available': # This condition might not be met correctly yet
                    # ... (rest of the selection logic remains, but might not find 'available') ...
                    pass # Simplified for brevity, original logic was complex
            else:
                 self.logger.warning(f"Could not determine availability status for originally selected name '{original_selected_name}'. Keeping original selection.")

            llm_data["selected_brand_name"] = final_selected_name_item


            # 6. Validate and Assemble Final Brand Package
            try:
                # Add target demographics back
                if 'target_demographics' not in llm_data:
                     llm_data['target_demographics'] = inputs.target_audience

                # Validate the final structure
                brand_package = BrandPackage(**llm_data)
                # Add the potentially incomplete availability notes
                brand_package.availability_notes = availability_notes
                self.logger.info("Successfully validated LLM data and added availability notes.")

            except Exception as e: # Catch Pydantic validation errors
                self.logger.error(f"Final data failed validation against BrandPackage model: {e}. Data: {llm_data}")
                raise ValueError(f"Final data failed validation: {e}") from e

            # 7. Return Success Event
            self.logger.info("Branding generation finished successfully (pending A2A refactor for availability checks).")
            # Use the context's create_event method for consistency
            return context.create_event(
                event_type="adk.agent.result",
                data=brand_package.model_dump(), # Serialize the Pydantic model
                metadata={"status": "success"}
            )

        except ValueError as ve: # Catch specific validation/parsing errors
             self.logger.error(f"BrandingAgent execution failed due to ValueError: {ve}", exc_info=True)
             # Use context's create_event for errors too
             return context.create_event(
                 event_type="adk.agent.error",
                 data={"error": "Input or LLM Response Error", "details": str(ve)},
                 metadata={"status": "error"}
             )
        except Exception as e: # Catch broader errors
            self.logger.error(f"BrandingAgent execution failed unexpectedly: {e}", exc_info=True)
            return context.create_event(
                event_type="adk.agent.error",
                data={"error": "Internal Agent Error", "details": f"An unexpected error occurred: {str(e)}"},
                metadata={"status": "error"}
            )


# --- FastAPI Server Setup ---

# Create FastAPI app
app = FastAPI(title="BrandingAgent A2A Server")

# Instantiate the agent (reads env vars internally now)
branding_agent_instance = BrandingAgent()

@app.post("/invoke", response_model=Dict[str, Any])
async def invoke_agent(request: BrandingAgentInput = Body(...)):
    """
    A2A endpoint to invoke the BrandingAgent.
    Expects a JSON body matching the BrandingAgentInput schema.
    """
    logfire.info(f"BrandingAgent /invoke called with concept: {request.product_concept}")
    # Create InvocationContext, passing data directly
    context = InvocationContext(agent_id="branding-agent", data=request.model_dump())

    try:
        result_event = await branding_agent_instance.run_async(context)
        if result_event and result_event.metadata.get("status") == "success":
            logfire.info(f"BrandingAgent returning success result.")
            return result_event.data # Return the data part of the event
        elif result_event:
             error_details = result_event.data.get("details", "Unknown agent error")
             logfire.error(f"BrandingAgent run_async returned error event: {error_details}")
             raise HTTPException(status_code=500, detail=f"Agent execution failed: {error_details}")
        else:
            logfire.error("BrandingAgent run_async returned None")
            raise HTTPException(status_code=500, detail="Agent execution failed to return an event.")
    except Exception as e:
        logfire.error(f"Error during agent invocation: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Internal server error: {e}")

@app.get("/health")
async def health_check():
    return {"status": "ok"}

# --- Main execution block ---

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Run the BrandingAgent A2A server.")
    parser.add_argument("--host", type=str, default="0.0.0.0", help="Host to bind the server to.")
    parser.add_argument("--port", type=int, default=8081, help="Port to run the server on (default from compose).") # Default matches compose
    args = parser.parse_args()

    print(f"Starting BrandingAgent A2A server on {args.host}:{args.port}")
    # Configure logfire (optional, adjust as needed)
    # logfire.configure()

    uvicorn.run(app, host=args.host, port=args.port)